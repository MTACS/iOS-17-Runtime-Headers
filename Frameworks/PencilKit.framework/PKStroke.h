
@interface PKStroke : NSObject <NSCopying>

@property (setter=_setBounds:, nonatomic) struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; } _bounds;
@property (getter=_isInProgressScribbleStroke, setter=_setIsInProgressScribbleStroke:, nonatomic) bool _isInProgressScribbleStroke;
@property (nonatomic, readonly) bool _isInternal;
@property (getter=_isNewCopy, setter=_setIsNewCopy:, nonatomic) bool _isNewCopy;
@property (setter=_setRenderMask:, nonatomic, copy) PKStrokeRenderMask *_renderMask;
@property (nonatomic, retain) PKStrokePath *_strokeData;
@property (nonatomic, readonly) NSUUID *_strokeDataUUID;
@property (setter=_setTransform:, nonatomic) struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; } _transform;
@property (nonatomic, readonly) struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; } _untransformedBounds;
@property (nonatomic, retain) PKInk *ink;
@property (nonatomic, readonly) UIBezierPath *mask;
@property (nonatomic, readonly) NSArray *maskedPathRanges;
@property (nonatomic, readonly) PKStrokePath *path;
@property (nonatomic, readonly) unsigned int randomSeed;
@property (nonatomic, readonly) struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; } renderBounds;
@property (nonatomic, readonly) long long requiredContentVersion;
@property (nonatomic, readonly) struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; } transform;

+ (long long)_asciiBitfieldIndexForX:(long long)arg1 y:(long long)arg2 width:(long long)arg3;
+ (long long)_asciiDimensionForBoundsDimension:(double)arg1;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })_calculateBounds:(id)arg1 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg2 ink:(id)arg3 inkTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg4 strokePath:(id)arg5;
+ (struct PKCompressedStrokePoint { struct _PKPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; unsigned short x4; unsigned short x5; unsigned short x6; unsigned short x7; unsigned short x8; unsigned short x9; float x10; })_compressStrokePoint:(struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })arg1 withTimestamp:(double)arg2;
+ (void)_consumeRenderVertexes:(id /* block */)arg1 ink:(id)arg2 inkTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg3 strokePath:(id)arg4;
+ (struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })_decompressStrokePoint:(struct PKCompressedStrokePoint { struct _PKPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; unsigned short x4; unsigned short x5; unsigned short x6; unsigned short x7; unsigned short x8; unsigned short x9; float x10; })arg1 withTimestamp:(double)arg2;
+ (id)_snapToShape:(id)arg1;
+ (id)_snapToShape:(id)arg1 inputScale:(double)arg2;
+ (id)_testStrokeFromPoints:(struct PKCompressedStrokePoint { struct _PKPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; unsigned short x4; unsigned short x5; unsigned short x6; unsigned short x7; unsigned short x8; unsigned short x9; float x10; }*)arg1 length:(long long)arg2 ink:(id)arg3;
+ (id)allocWithZone:(struct _NSZone { }*)arg1;
+ (id)copyStrokes:(id)arg1 hidden:(bool)arg2;
+ (id)sliceWithEraser:(const void*)arg1 toClip:(id)arg2;
+ (id)sliceWithEraser:(const void*)arg1 toClip:(id)arg2 clipType:(int)arg3;

- (void)_addVisibleSubstrokesTo:(id)arg1 inDrawing:(id)arg2;
- (struct CGPoint { double x1; double x2; })_anchorPointForTexture;
- (void)_appendPointsOfInterestForSelection:(void*)arg1;
- (void)_appendPointsOfInterestForSelection:(void*)arg1 step:(double)arg2;
- (void)_appendPointsOfInterestForSelectionMasked:(void*)arg1;
- (void)_applyTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (id)_ascii;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })_bounds;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })_calculateBounds;
- (id)_clipPlane;
- (struct unique_ptr<std::vector<PKCompressedStrokePoint>, std::default_delete<std::vector<PKCompressedStrokePoint>>> { struct __compressed_pair<std::vector<PKCompressedStrokePoint> *, std::default_delete<std::vector<PKCompressedStrokePoint>>> { void *x_1_1_1; } x1; })_compressedStrokePoints;
- (bool)_containsSamePointsAsStroke:(id)arg1;
- (struct { union { struct { unsigned int x_1_2_1 : 1; unsigned int x_1_2_2 : 1; unsigned int x_1_2_3 : 1; unsigned int x_1_2_4 : 1; unsigned int x_1_2_5 : 1; unsigned int x_1_2_6 : 32; unsigned int x_1_2_7 : 1; unsigned int x_1_2_8 : 1; unsigned int x_1_2_9 : 1; } x_1_1_1; unsigned long long x_1_1_2; } x1; })_flags;
- (id)_groupID;
- (id)_initWithPath:(struct CGPath { }*)arg1 ink:(id)arg2 inputScale:(double)arg3;
- (id)_initWithPath:(struct CGPath { }*)arg1 ink:(id)arg2 maxSegmentLength:(double)arg3 inputScale:(double)arg4 velocityForDistanceFunction:(id /* block */)arg5;
- (id)_ink;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })_inkTransform;
- (long long)_inputType;
- (bool)_isBitmapEraserStroke;
- (bool)_isHidden;
- (bool)_isInProgressScribbleStroke;
- (bool)_isInternal;
- (bool)_isMaskedStroke;
- (bool)_isNewCopy;
- (struct CGPoint { double x1; double x2; })_locationAtIndex:(unsigned long long)arg1;
- (struct CGPoint { double x1; double x2; })_locationAtIndex:(unsigned long long)arg1 applyStrokeTransform:(bool)arg2;
- (double)_maxWidthForStroke;
- (id)_mergeWithStroke:(id)arg1 inDrawing:(id)arg2;
- (bool*)_newAsciiBitfield;
- (bool*)_newAsciiBitfieldWithWidth:(long long)arg1 height:(long long)arg2;
- (struct CGPath { }*)_newPathRepresentation;
- (id)_newStrokeWithSubstrokes:(id)arg1 inDrawing:(id)arg2;
- (bool)_pathHasClockwisePointOrdering;
- (unsigned long long)_pointsCount;
- (unsigned int)_randomSeed;
- (id)_renderGroupID;
- (id)_renderMask;
- (void)_setBounds:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1;
- (void)_setClipPlane:(id)arg1;
- (void)_setFlags:(struct { union { struct { unsigned int x_1_2_1 : 1; unsigned int x_1_2_2 : 1; unsigned int x_1_2_3 : 1; unsigned int x_1_2_4 : 1; unsigned int x_1_2_5 : 1; unsigned int x_1_2_6 : 32; unsigned int x_1_2_7 : 1; unsigned int x_1_2_8 : 1; unsigned int x_1_2_9 : 1; } x_1_1_1; unsigned long long x_1_1_2; } x1; })arg1;
- (void)_setGroupID:(id)arg1;
- (void)_setHidden:(bool)arg1;
- (void)_setInk:(id)arg1;
- (void)_setInkTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (void)_setIsInProgressScribbleStroke:(bool)arg1;
- (void)_setIsNewCopy:(bool)arg1;
- (void)_setRandomSeed:(unsigned int)arg1;
- (void)_setRenderGroupID:(id)arg1;
- (void)_setRenderMask:(id)arg1;
- (void)_setShapeType:(long long)arg1;
- (void)_setStrokeMask:(id)arg1;
- (void)_setStrokeUUID:(id)arg1;
- (void)_setTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (long long)_shapeType;
- (bool)_shouldBeClippedAgainstLegacyCanvas;
- (id)_sliceWithSlicingBlock:(id /* block */)arg1 inDrawing:(id)arg2 newRootStroke:(id*)arg3;
- (id)_strokeData;
- (id)_strokeDataUUID;
- (id)_strokeMask;
- (id)_strokeUUID;
- (id)_substrokeWithRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (id)_substrokesInDrawing:(id)arg1;
- (double)_thresholdForPoint:(struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })arg1;
- (double)_timestamp;
- (double)_timestampAtIndex:(unsigned long long)arg1;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })_transform;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })_untransformedBounds;
- (id)_updateStroke:(id /* block */)arg1 inDrawing:(id)arg2;
- (long long)_visibleSubstrokeCountInDrawing:(id)arg1;
- (bool)_visitVisibleSubstrokes:(id /* block */)arg1 inDrawing:(id)arg2;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })bounds;
- (long long)compareToStroke:(id)arg1;
- (id)copyForMutation;
- (id)copyForSubstroke;
- (id)copyWithNewAnchorPointForTexture:(struct CGPoint { double x1; double x2; })arg1;
- (id)copyWithZone:(struct _NSZone { }*)arg1;
- (id)dataRepresentation;
- (id)debugQuickLookObject;
- (void)debugRender:(struct CGContext { }*)arg1;
- (void)debugRenderMasked:(struct CGContext { }*)arg1;
- (id)deltaTo:(id)arg1;
- (id)description;
- (id)descriptionAtDepth:(long long)arg1;
- (void)didUpdateInDrawing:(id)arg1;
- (void)didUpdateSubstrokesInDrawing:(id)arg1;
- (double)endTimestamp;
- (void)enumeratePointsWithDistanceStep:(double)arg1 usingBlock:(id /* block */)arg2;
- (void)enumeratePointsWithTimestep:(double)arg1 usingBlock:(id /* block */)arg2;
- (void)generateClipPaths:(void*)arg1 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg2;
- (void)generateClipperPath:(void*)arg1;
- (void)generateMask;
- (bool)hasSubstrokes;
- (unsigned long long)hash;
- (id)init;
- (id)initWithArchive:(const void*)arg1 error:(id*)arg2;
- (id)initWithData:(id)arg1 error:(id*)arg2;
- (id)initWithData:(id)arg1 id:(id)arg2 flags:(struct { union { struct { unsigned int x_1_2_1 : 1; unsigned int x_1_2_2 : 1; unsigned int x_1_2_3 : 1; unsigned int x_1_2_4 : 1; unsigned int x_1_2_5 : 1; unsigned int x_1_2_6 : 32; unsigned int x_1_2_7 : 1; unsigned int x_1_2_8 : 1; unsigned int x_1_2_9 : 1; } x_1_1_1; unsigned long long x_1_1_2; } x1; })arg3 ink:(id)arg4 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg5 substrokes:(id)arg6;
- (id)initWithData:(id)arg1 id:(id)arg2 hidden:(bool)arg3 ink:(id)arg4 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg5 substrokes:(id)arg6;
- (id)initWithInk:(id)arg1 strokePath:(id)arg2 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg3 mask:(id)arg4;
- (id)initWithInk:(id)arg1 strokePath:(id)arg2 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg3 mask:(id)arg4 randomSeed:(unsigned int)arg5;
- (id)ink;
- (void)interpolatePointDataWithStep:(double)arg1 from:(double)arg2 to:(double)arg3 usingBlock:(id /* block */)arg4;
- (void)interpolatePointDataWithStep:(double)arg1 usingBlock:(id /* block */)arg2;
- (struct CGPoint { double x1; double x2; })intersectionFromPoint:(struct CGPoint { double x1; double x2; })arg1 toPoint:(struct CGPoint { double x1; double x2; })arg2;
- (bool)intersectsClipperPath:(void*)arg1;
- (bool)intersectsClosedStroke:(id)arg1;
- (bool)intersectsClosedStrokeMasked:(id)arg1;
- (bool)intersectsLineFrom:(struct CGPoint { double x1; double x2; })arg1 to:(struct CGPoint { double x1; double x2; })arg2 minThreshold:(double)arg3;
- (bool)intersectsLineFromMasked:(struct CGPoint { double x1; double x2; })arg1 to:(struct CGPoint { double x1; double x2; })arg2 minThreshold:(double)arg3;
- (bool)intersectsPoint:(struct CGPoint { double x1; double x2; })arg1;
- (bool)intersectsPoint:(struct CGPoint { double x1; double x2; })arg1 boundsOutset:(double)arg2 minimumStrokeThreshold:(double)arg3;
- (bool)intersectsPointMasked:(struct CGPoint { double x1; double x2; })arg1;
- (bool)intersectsPointMasked:(struct CGPoint { double x1; double x2; })arg1 boundsOutset:(double)arg2 minimumStrokeThreshold:(double)arg3;
- (bool)intersectsRect:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1;
- (bool)intersectsRectMasked:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1;
- (bool)isEqual:(id)arg1;
- (struct CGPoint { double x1; double x2; })locationAtIndex:(unsigned long long)arg1;
- (id)mask;
- (id)maskedPathRanges;
- (id)mutableCopyWithZone:(struct _NSZone { }*)arg1;
- (void*)newOutlinePaths;
- (struct CGPath { }*)newPathRepresentation;
- (struct CGPath { }*)newPathRepresentationMasked;
- (struct CGPath { }*)newSelectionPathRepresentationWithPointsCount:(int*)arg1;
- (struct CGPath { }*)newSelectionPathRepresentationWithPointsCountMasked:(int*)arg1;
- (id)parentStrokeForInsertionInDrawing:(id)arg1;
- (id)path;
- (unsigned int)randomSeed;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })renderBounds;
- (long long)requiredContentVersion;
- (void)saveToArchive:(void*)arg1;
- (void)setInk:(id)arg1;
- (void)setPath:(id)arg1;
- (void)set_strokeData:(id)arg1;
- (id)sliceIdentifierForTStart:(double)arg1 tEnd:(double)arg2;
- (id)sliceWithEraser:(const void*)arg1;
- (id)sliceWithMask:(const void*)arg1;
- (double)startTimestamp;
- (id)strokeApplying:(id)arg1;
- (id)strokeWithInk:(id)arg1;
- (id)substrokeWithRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (double)timestamp;
- (double)timestampAtIndex:(unsigned long long)arg1;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })transform;

@end
