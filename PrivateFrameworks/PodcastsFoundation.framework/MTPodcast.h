
@interface MTPodcast : NSManagedObject <IMMetricsDataSource>

@property (nonatomic) double addedDate;
@property (nonatomic, retain) NSString *artworkPrimaryColor;
@property (nonatomic, retain) NSString *artworkTemplateURL;
@property (nonatomic, retain) NSString *artworkTextPrimaryColor;
@property (nonatomic, retain) NSString *artworkTextQuaternaryColor;
@property (nonatomic, retain) NSString *artworkTextSecondaryColor;
@property (nonatomic, retain) NSString *artworkTextTertiaryColor;
@property (getter=isAuthenticatedDark, nonatomic) bool authenticatedDark;
@property (nonatomic, retain) NSString *author;
@property (nonatomic, readonly) bool autoDownload;
@property (nonatomic) bool autoDownloadEnabled;
@property (nonatomic) int autoDownloadType;
@property (getter=isPastAutodownloadOrEpisodeLimitDark, nonatomic, readonly) bool autodownloadOrEpisodeLimitDark;
@property (nonatomic, retain) NSUUID *bootstrapGeneration;
@property (nonatomic, retain) NSString *category;
@property (nonatomic, retain) MTChannel *channel;
@property (nonatomic) long long channelStoreId;
@property (nonatomic) long long consecutiveFeedFetchErrors;
@property (nonatomic, readonly) bool currentEpisodeLimitAllowsAutomaticDownloads;
@property (nonatomic, readonly) bool currentEpisodeLimitIsNextNEpisodes;
@property (getter=isDark, nonatomic, readonly) bool dark;
@property (nonatomic) long long darkCount;
@property (nonatomic) long long darkCountLocal;
@property (readonly, copy) NSString *debugDescription;
@property (nonatomic) long long deletePlayedEpisodes;
@property (readonly, copy) NSString *description;
@property (nonatomic, retain) NSString *displayType;
@property (nonatomic) double downloadedDate;
@property (nonatomic) long long downloadedEpisodesCount;
@property (nonatomic) long long downloadedUnplayedEpisodesCount;
@property (nonatomic) long long episodeLimit;
@property (nonatomic, retain) NSSet *episodes;
@property (nonatomic, retain) NSString *etag;
@property (nonatomic) double feedChangedDate;
@property (nonatomic, retain) NSString *feedURL;
@property (nonatomic, copy) NSString *feedUniquenessHash;
@property (nonatomic) bool feedUpdateNeedsRetry;
@property (nonatomic) long long flags;
@property (nonatomic) bool hasBeenSynced;
@property (readonly) unsigned long long hash;
@property (nonatomic) bool hidden;
@property (nonatomic) int hidesPlayedEpisodes;
@property (nonatomic, retain) NSString *imageURL;
@property (nonatomic, retain) NSData *implicitFollowsUnknownSyncProperties;
@property (nonatomic) bool importing;
@property (nonatomic) bool isExplicit;
@property (nonatomic) bool isHiddenOrImplicitlyFollowed;
@property (nonatomic) bool isImplicitlyFollowed;
@property (nonatomic, retain) NSString *itemDescription;
@property (nonatomic) long long keepEpisodes;
@property (nonatomic) double lastDatePlayed;
@property (nonatomic) double lastDismissedEpisodeUpsellBannerDate;
@property (nonatomic) double lastFetchedDate;
@property (nonatomic) double lastImplicitlyFollowedDate;
@property (nonatomic) double lastRemovedFromUpNextDate;
@property (nonatomic) double lastStoreEpisodesInfoCheckDate;
@property (nonatomic) double lastStorePodcastInfoCheckDate;
@property (nonatomic) double lastTouchDate;
@property (nonatomic) double latestEpisodeAvailabilityTime;
@property (nonatomic, retain) NSDate *latestExitFromDarkDownloads;
@property (nonatomic) long long libraryEpisodesCount;
@property (nonatomic) double modifiedDate;
@property (nonatomic) bool needsArtworkUpdate;
@property (nonatomic) long long newEpisodesCount;
@property (nonatomic) long long newTrailersCount;
@property (nonatomic, retain) NSString *nextEpisodeUuid;
@property (nonatomic, copy) NSString *nextSyncToken;
@property (nonatomic) bool notifications;
@property (nonatomic) long long offerTypes;
@property (nonatomic) bool orphanedFromCloud;
@property (nonatomic) bool playbackNewestToOldest;
@property (nonatomic, readonly) bool playbackNewestToOldest;
@property (nonatomic, retain) NSSet *playlistSettings;
@property (nonatomic, retain) NSSet *playlists;
@property (nonatomic) long long podcastPID;
@property (nonatomic, retain) NSString *provider;
@property (nonatomic) long long savedEpisodesCount;
@property (nonatomic) long long savedUnplayedEpisodesCount;
@property (nonatomic, readonly) bool shouldBeDeleted;
@property (nonatomic, readonly) bool shouldBeHiddenFromUpNext;
@property (nonatomic) bool showPlacardForOrphanedFromCloud;
@property (nonatomic) bool showPlacardForRemovePlayedEpisodes;
@property (nonatomic) bool showPlacardForSavedEpisodes;
@property (nonatomic, retain) NSString *showSpecificUpsellCopy;
@property (nonatomic, retain) NSString *showTypeInFeed;
@property (nonatomic) long long showTypeSetting;
@property (nonatomic, readonly) bool sortAscending;
@property (nonatomic) bool sortAscending;
@property (nonatomic) long long sortOrder;
@property (nonatomic, retain) NSString *storeCleanURL;
@property (nonatomic) long long storeCollectionId;
@property (nonatomic, retain) NSString *storeShortURL;
@property (nonatomic) bool subscribed;
@property (readonly) Class superclass;
@property (nonatomic, retain) MTSyncInfo *syncInfo;
@property (nonatomic, readonly) long long syncType;
@property (nonatomic, retain) NSString *title;
@property (nonatomic, retain) NSString *uberArtworkTextPrimaryColor;
@property (nonatomic, retain) NSString *uberArtworkTextQuaternaryColor;
@property (nonatomic, retain) NSString *uberArtworkTextSecondaryColor;
@property (nonatomic, retain) NSString *uberArtworkTextTertiaryColor;
@property (nonatomic, retain) NSString *uberBackgroundImageURL;
@property (nonatomic, retain) NSString *uberBackgroundJoeColor;
@property (nonatomic) double updateAvg;
@property (nonatomic) long long updateInterval;
@property (nonatomic) double updateStdDev;
@property (nonatomic) double updatedDate;
@property (nonatomic, retain) NSString *updatedFeedURL;
@property (nonatomic, retain) NSString *uuid;
@property (nonatomic, retain) NSString *webpageURL;

// Image: /System/Library/PrivateFrameworks/PodcastsFoundation.framework/PodcastsFoundation

+ (id)_predicateForShowsWithPlayableFreeEpisodes;
+ (bool)autoDownloadDefaultValue;
+ (long long)defaultShowType;
+ (double)defaultUpdateInterval;
+ (long long)deletePlayedEpisodesDefaultValue;
+ (long long)episodeLimitDefaultValue;
+ (id)episodeLimitsAllowingAutomaticDownloads;
+ (bool)isRedirectURL:(id)arg1;
+ (id)podcastUuidForEpisodeUuid:(id)arg1 ctx:(id)arg2;
+ (id)predicateForAreMediaAPI:(bool)arg1;
+ (id)predicateForAutoDownloadEnabled;
+ (id)predicateForEntitledShows;
+ (id)predicateForExcludingExplicitBasedOnSetting;
+ (id)predicateForHasBeenSynced:(bool)arg1;
+ (id)predicateForHiddenOrImplicitlyFollowedPodcasts;
+ (id)predicateForHiddenPodcasts;
+ (id)predicateForIdentifer:(id)arg1;
+ (id)predicateForImplicitlyFollowedPodcasts;
+ (id)predicateForImplicitlyFollowedPodcastsExcludingUUIDs:(id)arg1;
+ (id)predicateForImporting:(bool)arg1;
+ (id)predicateForLastDatePlayedAfterDate:(id)arg1;
+ (id)predicateForLastDatePlayedNotInTheFuture;
+ (id)predicateForNonFollowedShowsWithPlayState;
+ (id)predicateForNotHiddenNotImplicitlyFollowedPodcasts;
+ (id)predicateForNotHiddenPodcasts;
+ (id)predicateForNotImplicitlyFollowedPodcasts;
+ (id)predicateForNotImplicitlyFollowedPodcastsWithChannelStoreId:(long long)arg1;
+ (id)predicateForNotSubscribedAndNotHiddenAndNotImplicitlyFollowed;
+ (id)predicateForNotSubscribedPodcasts;
+ (id)predicateForPaidSubscriptionActive:(bool)arg1;
+ (id)predicateForPeriodicallyUpdatablePodcasts;
+ (id)predicateForPodcastStoreIDs:(id)arg1;
+ (id)predicateForPodcastStoreId:(long long)arg1;
+ (id)predicateForPodcastToAutoRemove;
+ (id)predicateForPodcastUUID:(id)arg1;
+ (id)predicateForPodcastUuids:(id)arg1;
+ (id)predicateForPodcastWithFeedUrl:(id)arg1;
+ (id)predicateForPodcastWithPodcastPID:(long long)arg1;
+ (id)predicateForPodcastWithTitle:(id)arg1;
+ (id)predicateForPodcastsFetchedBefore:(id)arg1;
+ (id)predicateForPodcastsFollowedSince:(id)arg1;
+ (id)predicateForPodcastsNeedingRetry:(bool)arg1;
+ (id)predicateForPodcastsToAutodownload;
+ (id)predicateForPodcastsUpdatedBefore:(id)arg1;
+ (id)predicateForPodcastsWithBookmarkedEpisodes;
+ (id)predicateForPodcastsWithDownloadedEpisodes;
+ (id)predicateForPodcastsWithLibraryEpisodes;
+ (id)predicateForPodcastsWithUnplayedBookmarkedEpisodes;
+ (id)predicateForPodcastsWithUnplayedDownloadedEpisodes;
+ (id)predicateForSubscribedAndNotHidden;
+ (id)predicateForSubscribedPodcasts;
+ (id)predicateForWatchLibraryShows;
+ (id)productURLForStoreCollectionId:(long long)arg1 storeTrackId:(long long)arg2;
+ (id)propertiesToObserveForDownloadableEpisodes;
+ (id)redirectURLForStoreCollectionId:(long long)arg1;
+ (long long)showTypeFromString:(id)arg1;
+ (id)sortDescriptorsForNewestToOldest:(bool)arg1;
+ (id)sortDescriptorsForNewestToOldestFirstTimeAvailable:(bool)arg1;
+ (bool)sortOrderAscForShowType:(long long)arg1;
+ (long long)storeCollectionIdForRedirectURL:(id)arg1;
+ (unsigned long long)totalUnplayedCount;
+ (id)userDefaultPropertiesAffectingPredicates;

- (id)_episodeNextToEpisode:(id)arg1 after:(bool)arg2 usePlayOrder:(bool)arg3 restrictToUserEpisodes:(bool)arg4 excludePlayed:(bool)arg5 excludeExplicit:(long long)arg6 episodeTypeFilter:(long long)arg7;
- (id)_episodesNextTo:(double)arg1 after:(bool)arg2 usePlayOrder:(bool)arg3 sortAsc:(bool)arg4 restrictToUserEpisodes:(bool)arg5 excludePlayed:(bool)arg6 excludeExplicit:(long long)arg7 episodeTypeFilter:(long long)arg8 limit:(long long)arg9;
- (id)_episodesNextTo:(double)arg1 after:(bool)arg2 usePlayOrder:(bool)arg3 sortAsc:(bool)arg4 sortByEpisodeNumber:(bool)arg5 filter:(id)arg6 limit:(long long)arg7;
- (id)_episodesNextToEpisode:(id)arg1 after:(bool)arg2 usePlayOrder:(bool)arg3 restrictToUserEpisodes:(bool)arg4 excludePlayed:(bool)arg5 excludeExplicit:(long long)arg6 episodeTypeFilter:(long long)arg7 limit:(long long)arg8;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 filter:(id)arg3;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 restrictToUserEpisodes:(bool)arg3 excludePlayed:(bool)arg4 excludeExplicit:(long long)arg5;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 restrictToUserEpisodes:(bool)arg3 excludePlayed:(bool)arg4 excludeExplicit:(long long)arg5 episodeTypeFilter:(long long)arg6;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 restrictToUserEpisodes:(bool)arg3 excludePlayed:(bool)arg4 excludeExplicit:(long long)arg5 excludingEpisodeUuid:(id)arg6;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 restrictToUserEpisodes:(bool)arg3 excludePlayed:(bool)arg4 excludeExplicit:(long long)arg5 excludingEpisodeUuid:(id)arg6 episodeTypeFilter:(long long)arg7;
- (id)_latestOrOldestEpisode:(bool)arg1 sortDate:(unsigned long long)arg2 restrictToUserEpisodes:(bool)arg3 playStateFilter:(long long)arg4 excludeExplicit:(long long)arg5 excludingEpisodeUuid:(id)arg6 episodeTypeFilter:(long long)arg7;
- (void)applyFollowedShowSettingsFor:(long long)arg1;
- (void)applyUnfollowedShowSettings;
- (id)bestAvailableStoreCleanURL;
- (id)bestFeedURLExcludingRedirectURL:(bool)arg1;
- (void)calculateEpisodicNewEpisodeCountIn:(id)arg1;
- (void)calculateNewEpisodeCountIn:(id)arg1 serialShowsUseExperimentalRules:(bool)arg2;
- (void)calculateSerialNewEpisodeCountIn:(id)arg1;
- (double)calculatedUpdateInterval;
- (bool)currentEpisodeLimitAllowsAutomaticDownloads;
- (bool)currentEpisodeLimitIsNextNEpisodes;
- (id)currentFeedURL;
- (bool)deletePlayedEpisodesResolvedValue;
- (id)displayURL;
- (id)earliestDateForFeedFetch:(id)arg1;
- (long long)episodeLimitResolvedValue;
- (id)episodePublishedAfter:(double)arg1 filter:(id)arg2;
- (id)episodePublishedBefore:(double)arg1 filter:(id)arg2;
- (id)episodesInLatestSeasonWithLimit:(long long)arg1;
- (id)episodesInSeasonNumber:(long long)arg1;
- (id)episodesInSeasonNumber:(long long)arg1 lowestNumberedEpisodesFirst:(bool)arg2 filter:(id)arg3 limit:(long long)arg4;
- (id)episodesInSeasonNumber:(long long)arg1 oldestEpisodesFirst:(bool)arg2;
- (id)episodesInSeasonNumber:(long long)arg1 oldestEpisodesFirst:(bool)arg2 excludePlayed:(bool)arg3 excludeExplicit:(long long)arg4 episodeTypeFilter:(long long)arg5 limit:(unsigned long long)arg6;
- (id)episodesInSeasonNumber:(long long)arg1 oldestEpisodesFirst:(bool)arg2 excludePlayed:(bool)arg3 excludeExplicit:(long long)arg4 limit:(long long)arg5;
- (id)episodesInSeasonNumber:(long long)arg1 oldestEpisodesFirst:(bool)arg2 filter:(id)arg3 limit:(long long)arg4;
- (id)episodesPublishedAfter:(double)arg1 filter:(id)arg2 limit:(long long)arg3 sortAsc:(bool)arg4;
- (bool)feedUpdateNeedsRetry;
- (bool)hasBeenSynced;
- (id)highestNumberedEpisodePublishedBefore:(double)arg1 filter:(id)arg2;
- (id)highestNumberedPlayedEpisodeWithFilter:(id)arg1;
- (bool)importing;
- (bool)isAuthenticatedDark;
- (bool)isDark;
- (bool)isExplicit;
- (bool)isPastAutodownloadOrEpisodeLimitDark;
- (bool)isSerialShowTypeInFeed;
- (bool)isShareable;
- (long long)latestSeasonNumber;
- (unsigned long long)levelForDownloadsOnSubscription;
- (id)lowestNumberedEpisodePublishedAfter:(double)arg1 filter:(id)arg2;
- (id)lowestNumberedEpisodeWithFilter:(id)arg1;
- (id)metricsAdditionalData;
- (id)metricsContentIdentifier;
- (id)mostRecentlyPlayedEpisodeWithFilter:(id)arg1;
- (long long)mt_syncID;
- (bool)needsArtworkUpdate;
- (id)newestEpisode;
- (id)newestEpisodeByAvailabiltyTime;
- (id)newestEpisodeExcludingUuid:(id)arg1 excludeExplicit:(long long)arg2;
- (id)newestEpisodeWithFilter:(id)arg1;
- (id)newestFullEpisode;
- (id)newestUserEpisodeExcludingExplicit:(long long)arg1;
- (id)nextEpisodeNotPlayedExcludingExplicit:(long long)arg1 episodeTypeFilter:(long long)arg2;
- (id)nextNumberedUnplayedEpisodeAfter:(id)arg1 filter:(id)arg2;
- (id)oldestEpisodeExcludingExplicit:(long long)arg1;
- (id)oldestEpisodeExcludingExplicit:(long long)arg1 episodeTypeFilter:(long long)arg2;
- (id)oldestEpisodeInLatestSeasonOrShowWithFilter:(id)arg1;
- (id)oldestUserEpisodeExcludingExplicit:(long long)arg1;
- (bool)playbackNewestToOldest;
- (id)redirectURL;
- (bool)requestsAreNonAppInitiated;
- (void)resetGoDark;
- (void)setAuthenticatedDark:(bool)arg1;
- (void)setFeedUpdateNeedsRetry:(bool)arg1;
- (void)setFlags:(long long)arg1;
- (void)setHasBeenSynced:(bool)arg1;
- (void)setHidden:(bool)arg1;
- (void)setImporting:(bool)arg1;
- (void)setIsExplicit:(bool)arg1;
- (void)setIsImplicitlyFollowed:(bool)arg1;
- (void)setNeedsArtworkUpdate:(bool)arg1;
- (void)setPodcastPID:(long long)arg1;
- (id)shareURL;
- (bool)shouldBeDeleted;
- (bool)shouldBeHiddenFromUpNext;
- (long long)showTypeInFeedResolvedValue;
- (long long)showTypeUserSetting;
- (bool)sortAscending;
- (void)suppressEpisodesWithBasisDate:(id)arg1;
- (long long)syncType;
- (id)twitterShareURL;
- (void)updateIsHiddenOrImplicitlyFollowed;
- (void)updateLastImplicitlyFollowedDate;
- (void)updateLastTouchDate;
- (id)updatedAtString;
- (id)userEpisodesAfterEpisode:(id)arg1;

// Image: /System/Library/PrivateFrameworks/PodcastsKit.framework/PodcastsKit

+ (id)allPossibleEpisodeListSortOrderProperties;
+ (id)insertNewPodcastInManagedObjectContext:(id)arg1 subscribed:(bool)arg2 feedUrl:(id)arg3 showType:(long long)arg4 showTypeInFeed:(id)arg5 title:(id)arg6 author:(id)arg7 provider:(id)arg8 imageUrl:(id)arg9 description:(id)arg10 adamId:(long long)arg11 displayType:(id)arg12 showSpecificUpsellCopy:(id)arg13;
+ (id)insertNewPodcastInManagedObjectContext:(id)arg1 subscribed:(bool)arg2 feedUrl:(id)arg3 showType:(long long)arg4 showTypeInFeed:(id)arg5 title:(id)arg6 author:(id)arg7 provider:(id)arg8 imageUrl:(id)arg9 description:(id)arg10 displayType:(id)arg11 showSpecificUpsellCopy:(id)arg12;
+ (id)insertNewPodcastInManagedObjectContext:(id)arg1 subscribed:(bool)arg2 feedUrl:(id)arg3 showType:(long long)arg4 title:(id)arg5 author:(id)arg6 provider:(id)arg7 imageUrl:(id)arg8 description:(id)arg9;
+ (id)podcastUuidForFeedUrl:(id)arg1 ctx:(id)arg2;
+ (id)podcastUuidForFeedUrlString:(id)arg1 ctx:(id)arg2;
+ (id)predicateForSubscriptionSyncType:(long long)arg1;
+ (id)predicateForSyncablePodcastsForSyncType:(long long)arg1;
+ (void)prepareForPlatform:(id)arg1;
+ (void)setRemovePlayedDownloadsSetting:(long long)arg1 forPodcastUuid:(id)arg2;
+ (id)sortDescriptorsForAllPodcasts;
+ (id)sortDescriptorsForDateAddedAscending:(bool)arg1;
+ (id)sortDescriptorsForFirstTimeAvailableAscending:(bool)arg1;
+ (id)sortDescriptorsForLastDatePlayed;
+ (id)sortDescriptorsForManualOrder;
+ (id)sortDescriptorsForNewestOnTop;
+ (id)sortDescriptorsForOldestOnTop;
+ (id)sortDescriptorsForRecentlyUpdatedAscending:(bool)arg1;
+ (id)sortDescriptorsForSortType:(long long)arg1;
+ (id)sortDescriptorsForTitle:(bool)arg1;

- (id)_fetchRequestForDistinctSeasons;
- (void)_updateChannelRelationship:(id)arg1 deassociate:(bool)arg2;
- (void)applyShowTypeSetting:(long long)arg1;
- (id)bestDescription;
- (id)countOfNewEpisodes;
- (id)countOfUnplayedEpisodes;
- (unsigned long long)countOfUnplayedRssEpisodes;
- (bool)hasAtLeastOneSeason;
- (bool)hasMultipleSeasons;
- (bool)isValidShowTypeSetting:(long long)arg1;
- (void)markPlaylistsForUpdate;
- (void)prepareForDeletion;
- (id)seasonNumbers;
- (id)seasonSortDescriptorsForSortOrder;
- (id)seasonTrailerInSeason:(long long)arg1;
- (void)setAuthor:(id)arg1;
- (void)setChannel:(id)arg1;
- (void)setDeletePlayedEpisodes:(long long)arg1;
- (void)setFeedChangedDate:(double)arg1;
- (void)setImageURL:(id)arg1;
- (void)setItemDescription:(id)arg1;
- (void)setLastImplicitlyFollowedDate:(double)arg1;
- (void)setModifiedDate:(double)arg1;
- (void)setPlaybackNewestToOldest:(bool)arg1;
- (void)setShowTypeInFeed:(id)arg1;
- (void)setShowTypeSetting:(long long)arg1;
- (void)setSortAscending:(bool)arg1;
- (void)setSubscribed:(bool)arg1;
- (void)setTitle:(id)arg1;
- (void)setUpdateAvg:(double)arg1;
- (void)setUpdateStdDev:(double)arg1;
- (void)setUpdatedFeedURL:(id)arg1;
- (void)setWebpageURL:(id)arg1;
- (id)smartPlayEpisode;
- (bool)sortAscending;
- (id)sortDescriptorsForPlayOrder;
- (id)sortDescriptorsForPlayOrderByEpisodeNumber;
- (id)sortDescriptorsForPlayOrderByPubDate;
- (id)sortDescriptorsForSortOrder;
- (bool)updateCursorPosition:(bool)arg1;
- (void)updateEpisodesMetadataIdentifiers;

// Image: /System/Library/PrivateFrameworks/PodcastsUI.framework/PodcastsUI

+ (id)_defaultPlaceholderArtworkWithSize:(struct CGSize { double x1; double x2; })arg1;
+ (id)_imageFetchQueue;
+ (id)artworkForPodcastUuid:(id)arg1 size:(struct CGSize { double x1; double x2; })arg2 triggerDownload:(bool)arg3;
+ (void)asyncDiskArtworkForPodcastUuid:(id)arg1 size:(struct CGSize { double x1; double x2; })arg2 completion:(id /* block */)arg3;
+ (id)colorFromHexString:(id)arg1;
+ (void)downloadArtworkForPodcastIfNeeded:(id)arg1 successCallback:(id /* block */)arg2;
+ (void)fetchArtworkForPodcastUuid:(id)arg1 size:(struct CGSize { double x1; double x2; })arg2 completion:(id /* block */)arg3;
+ (bool)isImageCachedForPodcastUuid:(id)arg1;

- (id)artworkWithSize:(struct CGSize { double x1; double x2; })arg1;
- (void)fetchArtworkWithSize:(struct CGSize { double x1; double x2; })arg1 completion:(id /* block */)arg2;

@end
