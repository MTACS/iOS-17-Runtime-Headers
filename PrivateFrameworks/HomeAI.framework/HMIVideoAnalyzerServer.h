
@interface HMIVideoAnalyzerServer : HMIVideoAnalyzer <HMFTimerDelegate, HMIVideoAssetWriterDelegate, HMIVideoCommandBufferDelegate, HMIVideoDecoderDelegate, HMIVideoEncoderDelegate, HMIVideoFrameAnalyzerDelegate, HMIVideoFrameSamplerDelegate, HMIVideoFrameSelectorDelegate, HMIVideoFrameTrackerDelegate> {
    double  _analysisFPS;
    HMIVideoAssetWriter * _assetWriter;
    bool  _cancelled;
    HMIVideoCommandBuffer * _commandBuffer;
    struct { 
        long long value; 
        int timescale; 
        unsigned int flags; 
        long long epoch; 
    }  _currentDTS;
    struct { 
        long long value; 
        int timescale; 
        unsigned int flags; 
        long long epoch; 
    }  _currentPTS;
    HMIVideoDecoder * _decoder;
    HMIVideoEventBuffer * _dynamicConfigurationBuffer;
    bool  _encode;
    HMIVideoEncoder * _encoder;
    NSObject<OS_dispatch_queue> * _encoderQueue;
    HMIVideoFrameAnalyzer * _frameAnalyzer;
    HMIVideoEventBuffer * _frameAnalyzerFrameResultBuffer;
    HMIVideoFrameSelector * _frameSelector;
    HMIVideoFrameSampler * _frameThumbnailSampler;
    HMIVideoFrameSampler * _frameTimelapseSampler;
    HMIVideoFrameTracker * _frameTracker;
    bool  _hasFailed;
    NSData * _initializationSegment;
    struct opaqueCMFormatDescription { } * _inputAudioFormat;
    NSObject<OS_dispatch_queue> * _inputQueue;
    struct opaqueCMFormatDescription { } * _inputVideoFormat;
    NSDate * _lastFragmentReceivedDate;
    bool  _monitored;
    long long  _numDecodedSamples;
    long long  _numDidAnalyzeFragments;
    long long  _numDidAnalyzeFrames;
    long long  _numDidAnalyzePackages;
    long long  _numDidCreateTimelapseFragments;
    NSDate * _startDate;
    HMIVideoTemporalEventFilter * _temporalEventFilter;
    HMIVideoEventBuffer * _thumbnailBuffer;
    HMIVideoAssetWriter * _timelapseAssetWriter;
    HMIVideoEncoder * _timelapseEncoder;
    NSData * _timelapseInitializationSegment;
    struct opaqueCMFormatDescription { } * _timelapseOutputVideoFormat;
    HMIVideoTimeline * _timeline;
    HMFTimer * _watchdogTimer;
    NSObject<OS_dispatch_queue> * _workQueue;
}

@property (retain) HMIVideoAssetWriter *assetWriter;
@property (getter=isCancelled) bool cancelled;
@property (readonly) HMIVideoCommandBuffer *commandBuffer;
@property struct { long long x1; int x2; unsigned int x3; long long x4; } currentDTS;
@property struct { long long x1; int x2; unsigned int x3; long long x4; } currentPTS;
@property (readonly, copy) NSString *debugDescription;
@property (readonly) HMIVideoDecoder *decoder;
@property (readonly, copy) NSString *description;
@property (readonly) HMIVideoEventBuffer *dynamicConfigurationBuffer;
@property (retain) HMIVideoEncoder *encoder;
@property (readonly) NSObject<OS_dispatch_queue> *encoderQueue;
@property (readonly) HMIVideoFrameAnalyzer *frameAnalyzer;
@property (readonly) HMIVideoEventBuffer *frameAnalyzerFrameResultBuffer;
@property (readonly) HMIVideoFrameSelector *frameSelector;
@property (readonly) HMIVideoFrameSampler *frameThumbnailSampler;
@property (readonly) HMIVideoFrameSampler *frameTimelapseSampler;
@property (readonly) HMIVideoFrameTracker *frameTracker;
@property bool hasFailed;
@property (readonly) unsigned long long hash;
@property (retain) NSData *initializationSegment;
@property struct opaqueCMFormatDescription { }*inputAudioFormat;
@property (readonly) NSObject<OS_dispatch_queue> *inputQueue;
@property struct opaqueCMFormatDescription { }*inputVideoFormat;
@property (retain) NSDate *lastFragmentReceivedDate;
@property (readonly) NSDate *startDate;
@property (readonly) Class superclass;
@property (readonly) HMIVideoTemporalEventFilter *temporalEventFilter;
@property (readonly) HMIVideoEventBuffer *thumbnailBuffer;
@property (readonly) double timeSinceAnalyzerStarted;
@property (readonly) double timeSinceLastFragmentWasReceived;
@property (retain) HMIVideoAssetWriter *timelapseAssetWriter;
@property (retain) HMIVideoEncoder *timelapseEncoder;
@property (retain) NSData *timelapseInitializationSegment;
@property struct opaqueCMFormatDescription { }*timelapseOutputVideoFormat;
@property (readonly) HMIVideoTimeline *timeline;
@property (readonly) HMFTimer *watchdogTimer;
@property (readonly) NSObject<OS_dispatch_queue> *workQueue;

- (void).cxx_destruct;
- (void)_configureAssetWriter;
- (void)_configureEncoder;
- (void)_configureTimelapseAssetWriter;
- (void)_configureTimelapseEncoder;
- (void)_ensureDecoderForFragment:(id)arg1;
- (void)_ensureEncoder;
- (void)_ensureTimelapseEncoder;
- (id)_filterFrameResult:(id)arg1 dynamicConfiguration:(id)arg2 motionDetections:(id)arg3;
- (void)_handleDecodedSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1;
- (void)_notifyDelegateDidAnalyzeFragmentWithResult:(id)arg1;
- (void)_notifyDelegateDidAnalyzeFrameWithResult:(id)arg1;
- (void)_notifyDelegateDidCreateTimelapseFragment:(id)arg1;
- (void)_notifyDelegateDidFailWithError:(id)arg1;
- (void)_notifyDelegateDidProduceAnalysisStateUpdate:(id)arg1;
- (void)_prepareForInputVideoFormat:(struct opaqueCMFormatDescription { }*)arg1 audioFormat:(struct opaqueCMFormatDescription { }*)arg2;
- (void)_prepareForTimelapseOutputVideoFormat:(struct opaqueCMFormatDescription { }*)arg1;
- (void)_produceResult:(SEL)arg1 withArguments:(id)arg2;
- (void)_saveFragmentDataToDisk:(id)arg1 diskBufferSize:(unsigned long long)arg2;
- (double)analysisFPS;
- (id)assetWriter;
- (void)assetWriter:(id)arg1 didFailWithError:(id)arg2;
- (void)assetWriter:(id)arg1 didOutputInitializationSegment:(id)arg2;
- (void)assetWriter:(id)arg1 didOutputSeparableSegment:(id)arg2 segmentReport:(id)arg3;
- (void)buffer:(id)arg1 willHandleSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg2;
- (void)bufferWillFlush:(id)arg1;
- (void)cancel;
- (id)commandBuffer;
- (struct { long long x1; int x2; unsigned int x3; long long x4; })currentDTS;
- (struct { long long x1; int x2; unsigned int x3; long long x4; })currentPTS;
- (void)dealloc;
- (id)decoder;
- (void)decoder:(id)arg1 didDecodeSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg2;
- (void)decoder:(id)arg1 didFailWithError:(id)arg2;
- (double)delay;
- (id)dynamicConfigurationBuffer;
- (id)dynamicConfigurationForTime:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg1;
- (bool)encode;
- (id)encoder;
- (void)encoder:(id)arg1 didEncodeSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg2;
- (void)encoder:(id)arg1 didFailWithError:(id)arg2;
- (id)encoderQueue;
- (void)finishWithCompletionHandler:(id /* block */)arg1;
- (void)flush;
- (void)flushAsync;
- (id)frameAnalyzer;
- (void)frameAnalyzer:(id)arg1 didAnalyzeFrame:(id)arg2;
- (void)frameAnalyzer:(id)arg1 didProduceAnalysisStateUpdate:(id)arg2;
- (id)frameAnalyzerFrameResultBuffer;
- (void)frameSampler:(id)arg1 didSampleFrame:(struct opaqueCMSampleBuffer { }*)arg2;
- (id)frameSelector;
- (void)frameSelector:(id)arg1 didSelectFrame:(struct opaqueCMSampleBuffer { }*)arg2 reference:(struct opaqueCMSampleBuffer { }*)arg3;
- (void)frameSelector:(id)arg1 didSkipFrame:(struct opaqueCMSampleBuffer { }*)arg2;
- (struct opaqueCMSampleBuffer { }*)frameSelector:(id)arg1 prepareFrame:(struct opaqueCMSampleBuffer { }*)arg2;
- (id)frameThumbnailSampler;
- (id)frameTimelapseSampler;
- (id)frameTracker;
- (void)frameTracker:(id)arg1 didTrackFrame:(struct opaqueCMSampleBuffer { }*)arg2 background:(struct opaqueCMSampleBuffer { }*)arg3 motionDetections:(id)arg4 tracks:(id)arg5;
- (void)handleAssetData:(id)arg1 withOptions:(id)arg2 completionHandler:(id /* block */)arg3;
- (void)handleMessageWithOptions:(id)arg1 completionHandler:(id /* block */)arg2;
- (void)handleSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1 errorHandler:(id /* block */)arg2;
- (bool)hasFailed;
- (id)initWithConfiguration:(id)arg1 identifier:(id)arg2;
- (id)initializationSegment;
- (struct opaqueCMFormatDescription { }*)inputAudioFormat;
- (id)inputQueue;
- (struct opaqueCMFormatDescription { }*)inputVideoFormat;
- (bool)isCancelled;
- (id)lastFragmentReceivedDate;
- (bool)monitored;
- (void)setAnalysisFPS:(double)arg1;
- (void)setAssetWriter:(id)arg1;
- (void)setCancelled:(bool)arg1;
- (void)setCurrentDTS:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg1;
- (void)setCurrentPTS:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg1;
- (void)setEncode:(bool)arg1;
- (void)setEncoder:(id)arg1;
- (void)setHasFailed:(bool)arg1;
- (void)setInitializationSegment:(id)arg1;
- (void)setInputAudioFormat:(struct opaqueCMFormatDescription { }*)arg1;
- (void)setInputVideoFormat:(struct opaqueCMFormatDescription { }*)arg1;
- (void)setLastFragmentReceivedDate:(id)arg1;
- (void)setMonitored:(bool)arg1;
- (void)setTimelapseAssetWriter:(id)arg1;
- (void)setTimelapseEncoder:(id)arg1;
- (void)setTimelapseInitializationSegment:(id)arg1;
- (void)setTimelapseOutputVideoFormat:(struct opaqueCMFormatDescription { }*)arg1;
- (id)startDate;
- (id)state;
- (unsigned long long)status;
- (id)temporalEventFilter;
- (id)thumbnailBuffer;
- (double)timeSinceAnalyzerStarted;
- (double)timeSinceLastFragmentWasReceived;
- (id)timelapseAssetWriter;
- (id)timelapseEncoder;
- (id)timelapseInitializationSegment;
- (struct opaqueCMFormatDescription { }*)timelapseOutputVideoFormat;
- (id)timeline;
- (void)timerDidFire:(id)arg1;
- (id)watchdogTimer;
- (id)workQueue;

@end
