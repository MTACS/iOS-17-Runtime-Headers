
@interface STBlueprint : STUniquedManagedObject <STSerializableMappedObject, STUniquelySerializableManagedObject, STVersionVectorable>

@property (nonatomic, retain) NSSet *configurations;
@property (nonatomic, copy) NSDate *creationDate;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (readonly, copy) STDowntimeConfiguration *downtimeConfiguration;
@property (getter=isDowntimeEnabled) bool downtimeEnabled;
@property (readonly, copy) NSString *downtimeScheduleText;
@property (nonatomic) bool enabled;
@property (nonatomic, copy) NSDate *expiration;
@property (readonly) unsigned long long hash;
@property (nonatomic, copy) NSString *identifier;
@property (nonatomic) bool invertUsageLimit;
@property (nonatomic) bool isDirty;
@property (nonatomic) bool isTombstoned;
@property (readonly, copy) NSString *limitDisplayName;
@property (nonatomic) bool limitEnabled;
@property (readonly, copy) NSString *limitScheduleText;
@property (nonatomic, copy) NSDate *minimumInstallationDate;
@property (nonatomic, copy) NSDate *modificationDate;
@property (nonatomic, retain) STCoreOrganization *organization;
@property (retain) STCoreDowntimeOverride *override;
@property (nonatomic, retain) STBlueprintSchedule *schedule;
@property (readonly) Class superclass;
@property (nonatomic, copy) NSString *type;
@property (nonatomic, retain) STBlueprintUsageLimit *usageLimit;
@property (getter=isUsageLimitEnabled) bool usageLimitEnabled;
@property (nonatomic, retain) NSSet *users;
@property (nonatomic, copy) NSData *versionVector;

+ (void)_addCommonPredicatesForBlueprint:(id)arg1 toAllPredicates:(id)arg2 usingDateFormatter:(id)arg3 calendar:(id)arg4;
+ (void)_addExpirationPredicateForBlueprint:(id)arg1 toAllPredicates:(id)arg2 usingDateFormatter:(id)arg3;
+ (void)_addMinimumInstallationDatePredicateForBlueprint:(id)arg1 toAllPredicates:(id)arg2 usingDateFormatter:(id)arg3;
+ (void)_addSchedulePredicatesForBlueprintScheudle:(id)arg1 toAllPredicates:(id)arg2 usingDateFormatter:(id)arg3 calendar:(id)arg4;
+ (void)_addUserPredicateForBlueprint:(id)arg1 toAllPredicates:(id)arg2;
+ (void)_addWebDomains:(id)arg1 toItemNames:(id)arg2 remainingItems:(unsigned long long)arg3 totalCount:(unsigned long long)arg4 completionHandler:(id /* block */)arg5;
+ (id)_buildConfigurationsByDeclarationIdentifierFromBlueprint:(id)arg1 error:(id*)arg2;
+ (id)_buildDeclarationsFromConfigurationsByDeclarationIdentifier:(id)arg1 predicate:(id)arg2 identifier:(id)arg3;
+ (id)_buildPredicateForDisablingBlueprint:(id)arg1;
+ (id)_buildPredicateForUnspecializedBlueprint:(id)arg1 usingDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_cemPredicateWithDowntimeOverride:(id)arg1 shouldUseGracePeriod:(bool)arg2 dateFormater:(id)arg3 calendar:(id)arg4;
+ (id)_configurationForDowntime:(id)arg1 context:(id)arg2;
+ (void)_createDisplayNameWithItemNames:(id)arg1 itemCount:(unsigned long long)arg2 completionHandler:(id /* block */)arg3;
+ (id)_createDowntimeForUser:(id)arg1 organization:(id)arg2 context:(id)arg3;
+ (id)_declarationForDowntime:(id)arg1 user:(id)arg2 configuration:(id)arg3 behaviorType:(unsigned long long)arg4 context:(id)arg5 error:(id*)arg6;
+ (id)_declarationModeForBehaviorType:(unsigned long long)arg1;
+ (id)_downtimeForUser:(id)arg1 inContext:(id)arg2 error:(id*)arg3;
+ (id)_fetchOrCreateDowntimeForUserID:(id)arg1 inContext:(id)arg2 error:(id*)arg3;
+ (id)_fetchRequestMatchingBlueprintsForUserWithDSID:(id)arg1;
+ (id)_getDisplayNameAndAddCategories:(id)arg1 toItemNames:(id)arg2 remainingItems:(unsigned long long*)arg3;
+ (bool)_isStateChangeValid:(long long)arg1 forState:(long long)arg2;
+ (id)_organizationIdentifierForUser:(id)arg1 context:(id)arg2;
+ (id)_predicateForAlwaysAllowedAppsBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_predicateForDowntimeBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_predicateForManagedUserBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_predicateForRestrictionsBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_predicateForUsageLimitBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (id)_predicateForUsageLimitOverrideBlueprint:(id)arg1 withDateFormatter:(id)arg2 calendar:(id)arg3;
+ (bool)_updateConfiguration:(id)arg1 withDeclaration:(id)arg2 context:(id)arg3 error:(id*)arg4;
+ (id)_updatedDowntimeForUser:(id)arg1 startTime:(id)arg2 endTime:(id)arg3 scheduleByWeekdayIndex:(id)arg4 enabled:(bool)arg5 behaviorType:(unsigned long long)arg6 error:(id*)arg7;
+ (id)_updatedScheduleFromSchedule:(id)arg1 withStartTime:(id)arg2 endTime:(id)arg3 scheduleByWeekdayIndex:(id)arg4 context:(id)arg5;
+ (id)_userDSIDStringForUser:(id)arg1 context:(id)arg2;
+ (id)_userForUserID:(id)arg1 inContext:(id)arg2 error:(id*)arg3;
+ (id)applyAutomaticOnDemandDowntimeStateChange:(long long)arg1 forUserID:(id)arg2 context:(id)arg3 error:(id*)arg4;
+ (id)applyOnDemandDowntimeStateChange:(long long)arg1 withFixedDuration:(double)arg2 forUserID:(id)arg3 context:(id)arg4 error:(id*)arg5;
+ (id)applyScheduleStateChange:(long long)arg1 forUserID:(id)arg2 context:(id)arg3 error:(id*)arg4;
+ (id)blueprintIdentifierForUser:(id)arg1;
+ (id)createBlueprintWithType:(id)arg1 user:(id)arg2;
+ (id)createManagedUserBlueprintForUser:(id)arg1 error:(id*)arg2;
+ (id)customScheduleTimeRangeWithLocale:(id)arg1 startTimeComponents:(id)arg2 endTimeComponents:(id)arg3;
+ (id)defaultAlwaysAllowBundleIDs;
+ (id)defaultEndTime;
+ (id)defaultStartTime;
+ (bool)deleteManagedUserBlueprintForUser:(id)arg1 error:(id*)arg2;
+ (bool)deleteUsageLimitWithIdentifier:(id)arg1 user:(id)arg2 managedObjectContext:(id)arg3 error:(id*)arg4;
+ (bool)disableManagedUserBlueprintForUser:(id)arg1 error:(id*)arg2;
+ (id)displayNameForUsageLimitWithCategoryIdentifiers:(id)arg1 bundleIdentifiers:(id)arg2 webDomains:(id)arg3;
+ (id)downtimeConfigurationForUserID:(id)arg1 context:(id)arg2 error:(id*)arg3;
+ (void)fetchDisplayNameForUsageLimitWithCategoryIdentifiers:(id)arg1 bundleIdentifiers:(id)arg2 webDomains:(id)arg3 completionHandler:(id /* block */)arg4;
+ (id)fetchOrCreateWithDictionaryRepresentation:(id)arg1 inContext:(id)arg2 error:(id*)arg3;
+ (id)fetchRequestMatchingBlueprintsForUserWithDSID:(id)arg1 fromOrganization:(id)arg2;
+ (id)fetchRequestMatchingBlueprintsForUserWithDSID:(id)arg1 ofType:(id)arg2;
+ (id)fetchRequestMatchingBlueprintsForUserWithDSID:(id)arg1 ofType:(id)arg2 fromOrganization:(id)arg3;
+ (id)fetchRequestMatchingBlueprintsForUserWithDSID:(id)arg1 ofType:(id)arg2 withIdentifier:(id)arg3 fromOrganization:(id)arg4;
+ (id)fetchRequestMatchingExpiredBlueprints;
+ (id)fetchRequestMatchingOrphanedBlueprints;
+ (id)fetchRequestMatchingUnexpiredOneMoreMinuteBlueprints;
+ (id)fetchResultsRequestsForChangesToBlueprints;
+ (id)fetchResultsRequestsForChangesToBlueprintsForUserWithDSID:(id)arg1;
+ (id)keyPathsForValuesAffectingDowntimeScheduleText;
+ (id)keyPathsForValuesAffectingLimitDisplayName;
+ (id)keyPathsForValuesAffectingLimitScheduleText;
+ (bool)removeFixedDurationOnDemandDowntimeForUserID:(id)arg1 context:(id)arg2 error:(id*)arg3;
+ (bool)saveAlwaysAllowListForUser:(id)arg1 withBundleIDs:(id)arg2 error:(id*)arg3;
+ (bool)saveAlwaysAllowListForUser:(id)arg1 withBundleIDs:(id)arg2 overwriteExistingList:(bool)arg3 error:(id*)arg4;
+ (bool)saveDefaultAlwaysAllowListIfNecessaryForUser:(id)arg1 error:(id*)arg2;
+ (bool)saveDowntimeForUser:(id)arg1 startTime:(id)arg2 endTime:(id)arg3 scheduleByWeekdayIndex:(id)arg4 enabled:(bool)arg5 behaviorType:(unsigned long long)arg6 error:(id*)arg7;
+ (bool)saveManagedUserBlueprintForUser:(id)arg1 error:(id*)arg2;
+ (bool)saveRestrictionsBlueprintWithValuesForPresetRestrictions:(id)arg1 forUser:(id)arg2 error:(id*)arg3;
+ (bool)saveUsageLimitWithIdentifier:(id)arg1 user:(id)arg2 bundleIdentifiers:(id)arg3 webDomains:(id)arg4 categoryIdentifiers:(id)arg5 dailyBudgetLimit:(double)arg6 budgetLimitByWeekday:(id)arg7 enabled:(bool)arg8 behaviorType:(unsigned long long)arg9 error:(id*)arg10;
+ (id)scheduleTextWithLocale:(id)arg1 weekdayScheduleComparator:(id /* block */)arg2 scheduleTimeGetter:(id /* block */)arg3;
+ (id)serializableClassName;
+ (bool)shouldUseGracePeriodForDowntimeOverride:(id)arg1 configuration:(id)arg2;
+ (id)simpleScheduleTimeRangeWithStartTimeComponents:(id)arg1 endTimeComponents:(id)arg2;

- (id)_applyAutomaticOnDemandDowntimeStateChange:(long long)arg1 atDate:(id)arg2 inCalendar:(id)arg3 error:(id*)arg4;
- (id)_applyOnDemandDowntimeStateChange:(long long)arg1 withFixedDuration:(double)arg2 atDate:(id)arg3 inCalendar:(id)arg4 error:(id*)arg5;
- (id)_applyScheduleStateChange:(long long)arg1 atDate:(id)arg2 inCalendar:(id)arg3 error:(id*)arg4;
- (id)_downtimeConfigurationAtDate:(id)arg1 inCalendar:(id)arg2;
- (void)_reportCoreAnalyticsEventForDowntimeOverride:(id)arg1 currentDate:(id)arg2;
- (void)_updateActiveOverrideAfterScheduleChange;
- (id)_webFilterBlacklistStringsForURL:(id)arg1;
- (id)activeOverride;
- (id)applyAutomaticOnDemandDowntimeStateChange:(long long)arg1 error:(id*)arg2;
- (id)applyOnDemandDowntimeStateChange:(long long)arg1 withFixedDuration:(double)arg2 error:(id*)arg3;
- (id)applyScheduleStateChange:(long long)arg1 error:(id*)arg2;
- (void)awakeFromInsert;
- (id)computeUniqueIdentifier;
- (id)declarationsWithError:(id*)arg1;
- (id)dictionaryRepresentation;
- (void)didChangeValueForKey:(id)arg1;
- (void)disableDowntimeForDay:(unsigned long long)arg1;
- (id)downtimeConfiguration;
- (id)downtimeScheduleText;
- (bool)isDowntimeEnabled;
- (bool)isUsageLimitEnabled;
- (id)limitDisplayName;
- (id)limitScheduleText;
- (void)migrateToVersion2CategoriesIfNeeded;
- (bool)permitWebFilterURL:(id)arg1 pageTitle:(id)arg2 error:(id*)arg3;
- (bool)removeFixedDurationOnDemandDowntimeWithError:(id*)arg1;
- (void)setDowntimeEnabled:(bool)arg1;
- (void)setStartTime:(id)arg1 endTime:(id)arg2;
- (void)setStartTime:(id)arg1 endTime:(id)arg2 forDay:(unsigned long long)arg3;
- (void)setUsageLimitEnabled:(bool)arg1;
- (void)tombstone;
- (bool)updateWithDictionaryRepresentation:(id)arg1;

@end
