
@interface HDDatabase : NSObject <HDAnalyticsSubmissionCoordinatorDelegate, HDAssertionObserver, HDContentProtectionObserver, HDDatabaseConnectionPoolDelegate, HDDatabaseCorruptionEventStoreDelegate, HDDatabaseJournalDelegate, HDDatabaseMigrationTransactionDelegate, HDDiagnosticObject, HDHealthDaemonReadyObserver, HDHealthDatabase, HDProfileReadyObserver, HDSQLiteDatabaseDelegate, HDSQLiteDatabaseProvider> {
    NSMutableSet * _activeDatabases;
    NSConditionLock * _activeDatabasesLock;
    HDAssertionManager * _assertionManager;
    NSOperationQueue * _asynchronousOperationQueue;
    HDDatabaseJournal * _cloudSyncJournal;
    HDContentProtectionManager * _contentProtectionManager;
    NSObject<OS_dispatch_group> * _contentProtectionObservationGroup;
    long long  _corruptedMigrationAttemptsCount;
    NSMutableDictionary * _databaseJournalMergeObserverSetByType;
    NSDictionary * _databasePoolForType;
    NSUUID * _databaseUUID;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _databaseUUIDLock;
    bool  _didRunPostMigrationUpdates;
    bool  _disableTakingProtectedDataAssertionsWhenLocked;
    NSMutableDictionary * _extendedTransactions;
    NSMutableArray * _firstProtectedWriteTransactionBlocks;
    NSMutableArray * _firstUnlockBlocks;
    NSMutableArray * _firstUnprotectedWriteTransactionBlocks;
    _Atomic bool  _hasCompletedFirstJournalMergeCleanup;
    struct atomic_flag { 
        _Atomic bool _Value; 
    }  _hasFaultedForCorruptionError;
    bool  _hasFlushedForInactivity;
    bool  _hasFlushedProtectedData;
    _Atomic bool  _hasPendingSecondaryJournalMerge;
    double  _inactivityFlushInterval;
    NSObject<OS_dispatch_source> * _inactivityFlushTimer;
    _Atomic bool  _invalidated;
    bool  _isObservingContentProtection;
    HDDatabaseJournal * _journal;
    unsigned long long  _journalMergeEpoch;
    unsigned long long  _mergedJournalEpoch;
    NSHashTable * _migratedDatabases;
    double  _offsetTimeInterval;
    HDProfile * _profile;
    NSString * _profileDirectoryPath;
    NSDate * _protectedDataFlushDeadlineDate;
    NSObject<OS_dispatch_source> * _protectedDataFlushDeadlineTimer;
    double  _protectedDataFlushInterval;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _protectedDataLock;
    long long  _protectedDataLock_observedContentProtectionState;
    HKObserverSet * _protectedDataObservers;
    NSObject<OS_dispatch_queue> * _protectedDataQueue;
    long long  _protectedDataState;
    NSMutableDictionary * _protectedResourceAssertionsByIdentifier;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _protectedResourceAssertionsLock;
    NSHashTable * _protectedResourceStores;
    NSLock * _schemaMigrationLock;
    HDXPCGatedActivity * _secondaryJournalMergeActivity;
    NSObject<OS_dispatch_queue> * _serialAsynchronousQueue;
    bool  _shouldNotifyFirstUnlockObservers;
    _Atomic bool  _shouldPerformHFDVerificationAfterSecondaryJournalMerge;
    _Atomic bool  _started;
    NSString * _threadLocalTransactionContextStackKey;
    NSString * _threadLocalTransactionKey;
    NSObject<OS_dispatch_group> * _transactionStartGroup;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _transactionStartLock;
    id /* block */  _unitTest_didWaitForJournalMergeHandler;
    NSLock * _writeLock;
}

@property (nonatomic, readonly) HDDatabaseJournal *cloudSyncJournal;
@property (nonatomic, readonly) HDContentProtectionManager *contentProtectionManager;
@property (nonatomic) long long corruptedMigrationAttemptsCount;
@property (getter=isDataProtectedByFirstUnlockAvailable, nonatomic, readonly) bool dataProtectedByFirstUnlockAvailable;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (nonatomic) bool didRunPostMigrationUpdates;
@property (readonly) unsigned long long hash;
@property (nonatomic) double inactivityFlushInterval;
@property (nonatomic, readonly) HDDatabaseJournal *journal;
@property (nonatomic, readonly, copy) NSDate *mostRecentObliterationDate;
@property (nonatomic) double offsetTimeInterval;
@property (nonatomic) HDProfile *profile;
@property (nonatomic, readonly, copy) NSString *profileDirectoryPath;
@property (nonatomic, readonly, copy) HKProfileIdentifier *profileIdentifier;
@property (getter=isProtectedDataAvailable, nonatomic, readonly) bool protectedDataAvailable;
@property (nonatomic) double protectedDataFlushInterval;
@property (readonly) Class superclass;
@property (nonatomic, copy) id /* block */ unitTest_didWaitForJournalMergeHandler;

+ (id)allCurrentAndFutureEntityClasses;
+ (id)allEntityClassesWithBehavior:(id)arg1;

- (void).cxx_destruct;
- (id)HFDSizeInBytes;
- (id)_journalForType:(long long)arg1;
- (id)_newCorruptionEventStore;
- (id)_newDatabaseConnectionWithURL:(id)arg1;
- (id)_newTTRPromptControllerWithProfile:(id)arg1 domainName:(id)arg2 loggingCategory:(id)arg3;
- (void)_reportDatabaseMigrationStatus:(long long)arg1 component:(long long)arg2 schemaVersion:(long long)arg3 error:(id)arg4;
- (void)_reportSQLiteCorruption:(id)arg1 forDatabase:(long long)arg2 shouldPrompt:(bool)arg3;
- (bool)accessHighFrequencyDataStoreWithError:(id*)arg1 block:(id /* block */)arg2;
- (void)addDatabaseJournalMergeObserver:(id)arg1 journalType:(long long)arg2 queue:(id)arg3;
- (bool)addJournalEntries:(id)arg1 error:(id*)arg2;
- (bool)addJournalEntry:(id)arg1 error:(id*)arg2;
- (void)addProtectedDataObserver:(id)arg1;
- (void)addProtectedDataObserver:(id)arg1 queue:(id)arg2;
- (id)allEntityClassesWithProtectionClass:(long long)arg1;
- (id)allSeriesEntityClasses;
- (void)assertionManager:(id)arg1 assertionInvalidated:(id)arg2;
- (id)beginExtendedTransactionWithContext:(id)arg1 transactionTimeout:(double)arg2 continuationTimeout:(double)arg3 error:(id*)arg4;
- (void)checkInDatabase:(id)arg1 type:(long long)arg2 protectedResources:(id)arg3;
- (id)checkOutProtectedDatabase:(id)arg1 error:(id*)arg2;
- (id)checkOutProtectedResources:(id)arg1 error:(id*)arg2;
- (id)checkOutUnprotectedDatabase:(id)arg1 error:(id*)arg2;
- (id)cloneAccessibilityAssertion:(id)arg1 ownerIdentifier:(id)arg2 error:(id*)arg3;
- (id)cloudSyncJournal;
- (id)contentProtectionManager;
- (void)contentProtectionStateChanged:(long long)arg1 previousState:(long long)arg2;
- (long long)corruptedMigrationAttemptsCount;
- (void)daemonReady:(id)arg1;
- (void)databaseJournalMergeDidComplete:(id)arg1;
- (void)databasePool:(id)arg1 didFlushConnections:(id)arg2;
- (id)databasePoolForDatabaseType:(long long)arg1;
- (id)databaseSizeInBytesExcludingHFD;
- (id)databaseSizeInBytesForTypeUnprotected:(bool)arg1 WAL:(bool)arg2;
- (id)databaseUUIDWithError:(id*)arg1;
- (void)dealloc;
- (id)diagnosticDescription;
- (bool)didRunPostMigrationUpdates;
- (id)extendedDatabaseTransactionForIdentifier:(id)arg1;
- (void)finalizeExtendedTransactionForIdentifier:(id)arg1;
- (double)inactivityFlushInterval;
- (id)initWithProfile:(id)arg1 concurrentReaderLimit:(unsigned long long)arg2;
- (void)invalidateAndWait;
- (bool)isDataProtectedByFirstUnlockAvailable;
- (bool)isProtectedDataAvailable;
- (id)journal;
- (unsigned long long)journalChapterCountForType:(long long)arg1;
- (void)migrationTransaction:(id)arg1 didCreateDatabasesWithIdentifier:(id)arg2;
- (void)migrationTransaction:(id)arg1 didEncounterDatabaseMismatchWithUnprotectedIdentifier:(id)arg2 protectedIdentifier:(id)arg3;
- (id)migrationTransaction:(id)arg1 entityClassesWithBehavior:(id)arg2;
- (void)migrationTransaction:(id)arg1 reportHFDMigrationStatus:(long long)arg2 schemaVersion:(long long)arg3 error:(id)arg4;
- (id)mostRecentObliterationDate;
- (id)newConnectionForPool:(id)arg1 error:(id*)arg2;
- (void)obliterateWithReason:(id)arg1 preserveCopy:(bool)arg2;
- (double)offsetTimeInterval;
- (void)performAsynchronously:(id /* block */)arg1;
- (void)performAsynchronouslySerial:(id /* block */)arg1;
- (bool)performHighPriorityTransactionsWithError:(id*)arg1 block:(id /* block */)arg2;
- (void)performInFirstProtectedWriteTransaction:(id /* block */)arg1;
- (void)performInFirstUnprotectedWriteTransaction:(id /* block */)arg1;
- (bool)performTransactionWithContext:(id)arg1 error:(id*)arg2 block:(id /* block */)arg3 inaccessibilityHandler:(id /* block */)arg4;
- (void)performWhenDataProtectedByFirstUnlockIsAvailable:(id /* block */)arg1;
- (void)performWhenDataProtectedByFirstUnlockIsAvailableOnQueue:(id)arg1 block:(id /* block */)arg2;
- (bool)performWithJournalType:(long long)arg1 error:(id*)arg2 block:(id /* block */)arg3;
- (bool)performWithTransactionContext:(id)arg1 error:(id*)arg2 block:(id /* block */)arg3;
- (id)profile;
- (void)profileDidBecomeReady:(id)arg1;
- (id)profileDirectoryPath;
- (id)profileIdentifier;
- (id)progressForJournalMergeWithType:(long long)arg1;
- (double)protectedDataFlushInterval;
- (void)removeDatabaseJournalMergeObserver:(id)arg1 journalType:(long long)arg2;
- (void)removeProtectedDataObserver:(id)arg1;
- (void)reportDailyAnalyticsWithCoordinator:(id)arg1 completion:(id /* block */)arg2;
- (void)setCorruptedMigrationAttemptsCount:(long long)arg1;
- (void)setDidRunPostMigrationUpdates:(bool)arg1;
- (void)setInactivityFlushInterval:(double)arg1;
- (void)setOffsetTimeInterval:(double)arg1;
- (void)setProfile:(id)arg1;
- (void)setProtectedDataFlushInterval:(double)arg1;
- (void)setUnitTest_didWaitForJournalMergeHandler:(id /* block */)arg1;
- (void)start;
- (id)store:(id)arg1 objectForKey:(id)arg2;
- (void)store:(id)arg1 setObject:(id)arg2 forKey:(id)arg3;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)arg1 shouldPerformTransaction:(bool)arg2 timeout:(double)arg3 error:(id*)arg4;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)arg1 timeout:(double)arg2 error:(id*)arg3;
- (void)unitTest_clearFirstJournalMergeCleanupFlag;
- (id)unitTest_currentTransaction;
- (id /* block */)unitTest_didWaitForJournalMergeHandler;
- (void)unitTest_disableDatabaseAccessibilityAssertions;
- (void)unitTest_enableDatabaseAccessibilityAssertions;
- (void)unitTest_setContentProtectionStateAndWait:(long long)arg1;

@end
